<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solver APIs · RATiLQR.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="RATiLQR.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">RATiLQR.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><a class="tocitem" href="../optimal-control/">Optimal Control Problems</a></li><li class="is-active"><a class="tocitem" href>Solver APIs</a><ul class="internal"><li><a class="tocitem" href="#iLQG/iLEQG-Solver"><span>iLQG/iLEQG Solver</span></a></li><li><a class="tocitem" href="#RAT-iLQR-Solver"><span>RAT iLQR Solver</span></a></li><li><a class="tocitem" href="#RAT-iLQR-Solver-2"><span>RAT iLQR++ Solver</span></a></li><li><a class="tocitem" href="#PETS-Solver"><span>PETS Solver</span></a></li><li><a class="tocitem" href="#The-solve!-Function"><span>The <code>solve!</code> Function</span></a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Solver APIs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solver APIs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/StanfordMSL/RATiLQR.jl/blob/master/docs/source/solvers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Solver-APIs"><a class="docs-heading-anchor" href="#Solver-APIs">Solver APIs</a><a id="Solver-APIs-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-APIs" title="Permalink"></a></h1><h2 id="iLQG/iLEQG-Solver"><a class="docs-heading-anchor" href="#iLQG/iLEQG-Solver">iLQG/iLEQG Solver</a><a id="iLQG/iLEQG-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#iLQG/iLEQG-Solver" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RATiLQR.ILEQGSolver" href="#RATiLQR.ILEQGSolver"><code>RATiLQR.ILEQGSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">iLEQGSolver(problem::FiniteHorizonRiskSensitiveOptimalControlProblems, kwargs...)</code></pre><p>iLQG and iLEQG Solver for <code>problem</code>.</p><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>μ_min::Float64</code> – minimum value for Hessian regularization parameter <code>μ</code> (&gt; 0). Default: <code>1e-6</code>.</li><li><code>Δ_0::Float64</code> – minimum multiplicative modification factor (&gt; 0) for <code>μ</code>. Default: <code>2.0</code>.</li><li><code>λ::Float64</code> – multiplicative modification factor in (0, 1) for line search step size <code>ϵ</code>. Default: <code>0.5</code>.</li><li><code>d::Float64</code> – convergence error norm threshold (&gt; 0). If the maximum l2 norm of the change in nominal control over the horizon is less than <code>d</code>, the solver is considered to be converged. Default: <code>1e-2</code>.</li><li><code>iter_max::Int64</code> – maximum iteration number. Default: 100.</li><li><code>β::Float64</code> – Armijo condition number (&gt;= 0) defining a sufficient decrease for backtracking line search. If <code>β == 0</code>, then any cost-to-go improvement is considered a sufficient decrease. Default: <code>1e-4</code>.</li><li><code>ϵ_init::Float64</code> – initial step size in (<code>ϵ_min</code>, 1] to start the backtracking line search with. If <code>adaptive_ϵ_init</code> is <code>true</code>, then this value is overridden by the solver&#39;s adaptive initialization functionality after the first iLEQG iteration. If <code>adaptive_ϵ_init</code> is <code>false</code>, the specified value of <code>ϵ_init</code> is used across all the iterations as the initial step size. Default:<code>1.0</code>.</li><li><code>adaptive_ϵ_init::Bool</code> – if <code>true</code>, <code>ϵ_init</code> is adaptively changed based on the last step size <code>ϵ</code> of the previous iLEQG iteration. Default: <code>false</code>.<ul><li>If the first line search iterate <code>ϵ_init_prev</code> in the previous iLEQG iteration is successful, then <code>ϵ_init</code> for the next iLEQG iteration is set to <code>ϵ_init = ϵ_init_prev / λ</code> so that the initial line search step increases.</li><li>Otherwise <code>ϵ_init = ϵ_last</code> where <code>ϵ_last</code> is the line search step accepted in the previous iLEQG iteration.</li></ul></li><li><code>ϵ_min::Float64</code> – minimum value of step size <code>ϵ</code> to terminate the line search. When <code>ϵ_min</code> is reached, the last candidate nominal trajectory is accepted regardless of the Armijo condition and the current iLEQG iteration is finished. Default: <code>1e-6</code>.</li><li><code>f_returns_jacobian::Bool</code> – if <code>true</code>, Jacobian matrices of the dynamics function are user-provided. This can reduce computation time since automatic differentiation is not used. Default: <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StanfordMSL/RATiLQR.jl/blob/fc0322cd48fced3bb920a9e90598528765ac73f8/src/ileqg.jl#L125-L164">source</a></section></article><h2 id="RAT-iLQR-Solver"><a class="docs-heading-anchor" href="#RAT-iLQR-Solver">RAT iLQR Solver</a><a id="RAT-iLQR-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#RAT-iLQR-Solver" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RATiLQR.CrossEntropyBilevelOptimizationSolver" href="#RATiLQR.CrossEntropyBilevelOptimizationSolver"><code>RATiLQR.CrossEntropyBilevelOptimizationSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CrossEntropyBilevelOptimizationSolver(kwargs...)</code></pre><p>RAT iLQR (i.e. Cross Entropy Method + iLEQG) Solver.</p><p><strong>Optional Keyword Arguments</strong></p><p><strong>iLEQG Solver Parameters</strong></p><ul><li><code>μ_min_ileqg::Float64</code> – minimum value for Hessian regularization parameter <code>μ</code> (&gt; 0). Default: <code>1e-6</code>.</li><li><code>Δ_0_ileqg::Float64</code> – minimum multiplicative modification factor (&gt; 0) for <code>μ</code>. Default: <code>2.0</code>.</li><li><code>λ_ileqg::Float64</code> – multiplicative modification factor in (0, 1) for line search step size <code>ϵ</code>. Default: <code>0.5</code>.</li><li><code>d_ileqg::Float64</code> – convergence error norm threshold (&gt; 0). If the maximum l2 norm of the change in nominal control over the horizon is less than <code>d</code>, the solver is considered to be converged. Default: <code>1e-2</code>.</li><li><code>iter_max_ileqg::Int64</code> – maximum iteration number. Default: 100</li><li><code>β_ileqg::Float64</code> – Armijo condition number (&gt;= 0) defining a sufficient decrease for backtracking line search. If <code>β == 0</code>, then any cost-to-go improvement is considered a sufficient decrease. Default: <code>1e-4</code>.</li><li><code>ϵ_init_ileqg::Float64</code> – initial step size in (<code>ϵ_min</code>, 1] to start the backtracking line search with. If <code>adaptive_ϵ_init</code> is <code>true</code>, then this value is overridden by the solver&#39;s adaptive initialization functionality after the first iLEQG iteration. If <code>adaptive_ϵ_init</code> is <code>false</code>, the specified value of <code>ϵ_init</code> is used across all the iterations as the initial step size. Default:<code>1.0</code>.</li><li><code>adaptive_ϵ_init_ileqg::Bool</code> – if <code>true</code>, <code>ϵ_init</code> is adaptively changed based on the last step size <code>ϵ</code> of the previous iLEQG iteration. Default: <code>false</code>.<ul><li>If the first line search iterate <code>ϵ_init_prev</code> in the previous iLEQG iteration is successful, then <code>ϵ_init</code> for the next iLEQG iteration is set to <code>ϵ_init = ϵ_init_prev / λ</code> so that the initial line search step increases.</li><li>Otherwise <code>ϵ_init = ϵ_last</code> where <code>ϵ_last</code> is the line search step accepted in the previous iLEQG iteration.</li></ul></li><li><code>ϵ_min_ileqg::Float64</code> – minimum value of step size <code>ϵ</code> to terminate the line search. When <code>ϵ_min</code> is reached, the last candidate nominal trajectory is accepted regardless of the Armijo condition and the current iLEQG iteration is finished. Default: <code>1e-6</code>.</li><li><code>f_returns_jacobian::Bool</code> – if <code>true</code>, Jacobian matrices of the dynamics function are user-provided. This can reduce computation time since automatic differentiation is not used. Default: <code>false</code>.</li></ul><p><strong>Cross Entropy Solver Parameters</strong></p><ul><li><code>μ_init::Float64</code> – initial value of the mean parameter <code>μ</code> used in the first Cross Entropy iteration. Default: <code>1.0</code>.</li><li><code>σ_init::Float64</code> – initial value of the standard deviation parameter <code>σ</code> used in the first Cross Entropy iteration. Default: <code>2.0</code>.</li><li><code>num_samples::Int64</code> – number of Monte Carlo samples for the risk-sensitivity parameter <code>θ</code>. Default: <code>10</code>.</li><li><code>num_elite::Int64</code> – number of elite samples. Default: <code>3</code>.</li><li><code>iter_max::Int64</code> – maximum iteration number. Default: <code>5</code>.</li><li><code>λ::Float64</code> – multiplicative modification factor in (0, 1) for `<code>μ_init</code> and <code>σ_init</code>. Default: <code>0.5</code>.</li><li><code>use_θ_max::Bool</code> – if <code>true</code>, the maximum feasible <code>θ</code> found is used to perform the final iLEQG optimization instead of the optimal one. Default: <code>false</code>.</li></ul><p><strong>Notes</strong></p><ul><li>The values of <code>μ_init</code> and <code>σ_init</code>, which may be modified during optimization, are stored internally in the solver and　carried over to the next call to <code>solve!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StanfordMSL/RATiLQR.jl/blob/fc0322cd48fced3bb920a9e90598528765ac73f8/src/cross_entropy_bilevel_optimization.jl#L14-L72">source</a></section></article><h2 id="RAT-iLQR-Solver-2"><a class="docs-heading-anchor" href="#RAT-iLQR-Solver-2">RAT iLQR++ Solver</a><a class="docs-heading-anchor-permalink" href="#RAT-iLQR-Solver-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RATiLQR.NelderMeadBilevelOptimizationSolver" href="#RATiLQR.NelderMeadBilevelOptimizationSolver"><code>RATiLQR.NelderMeadBilevelOptimizationSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NelderMeadBilevelOptimizationSolver(kwargs...)</code></pre><p>RAT iLQR++ (i.e. Nelder-Mead Simplex Method + iLEQG) Solver.</p><p><strong>Optional Keyword Arguments</strong></p><p><strong>iLEQG Solver Parameters</strong></p><ul><li><code>μ_min_ileqg::Float64</code> – minimum value for Hessian regularization parameter <code>μ</code> (&gt; 0). Default: <code>1e-6</code>.</li><li><code>Δ_0_ileqg::Float64</code> – minimum multiplicative modification factor (&gt; 0) for <code>μ</code>. Default: <code>2.0</code>.</li><li><code>λ_ileqg::Float64</code> – multiplicative modification factor in (0, 1) for line search step size <code>ϵ</code>. Default: <code>0.5</code>.</li><li><code>d_ileqg::Float64</code> – convergence error norm threshold (&gt; 0). If the maximum l2 norm of the change in nominal control over the horizon is less than <code>d</code>, the solver is considered to be converged. Default: <code>1e-2</code>.</li><li><code>iter_max_ileqg::Int64</code> – maximum iteration number. Default: 100.</li><li><code>β_ileqg::Float64</code> – Armijo condition number (&gt;= 0) defining a sufficient decrease for backtracking line search. If <code>β == 0</code>, then any cost-to-go improvement is considered a sufficient decrease. Default: <code>1e-4</code>.</li><li><code>ϵ_init_ileqg::Float64</code> – initial step size in (<code>ϵ_min</code>, 1] to start the backtracking line search with. If <code>adaptive_ϵ_init</code> is <code>true</code>, then this value is overridden by the solver&#39;s adaptive initialization functionality after the first iLEQG iteration. If <code>adaptive_ϵ_init</code> is <code>false</code>, the specified value of <code>ϵ_init</code> is used across all the iterations as the initial step size. Default:<code>1.0</code>.</li><li><code>adaptive_ϵ_init_ileqg::Bool</code> – if <code>true</code>, <code>ϵ_init</code> is adaptively changed based on the last step size <code>ϵ</code> of the previous iLEQG iteration. Default: <code>false</code>.<ul><li>If the first line search iterate <code>ϵ_init_prev</code> in the previous iLEQG iteration is successful, then <code>ϵ_init</code> for the next iLEQG iteration is set to <code>ϵ_init = ϵ_init_prev / λ</code> so that the initial line search step increases.</li><li>Otherwise <code>ϵ_init = ϵ_last</code> where <code>ϵ_last</code> is the line search step accepted in the previous iLEQG iteration.</li></ul></li><li><code>ϵ_min_ileqg::Float64</code> – minimum value of step size <code>ϵ</code> to terminate the line search. When <code>ϵ_min</code> is reached, the last candidate nominal trajectory is accepted regardless of the Armijo condition and the current iLEQG iteration is finished. Default: <code>1e-6</code>.</li><li><code>f_returns_jacobian::Bool</code> – if <code>true</code>, Jacobian matrices of the dynamics function are user-provided. This can reduce computation time since automatic differentiation is not used. Default: <code>false</code>.</li></ul><p><strong>Nelder-Mead Simplex Solver Parameters</strong></p><ul><li><code>α::Float64</code> – reflection parameter. Default: <code>1.0</code>.</li><li><code>β::Float64</code> – expansion parameter. Default: <code>2.0</code>.</li><li><code>γ::Float64</code> – contraction parameter. Default: <code>0.5</code>.</li><li><code>ϵ::Float64</code> – convergence parameter. The algorithm is said to have convergeced  if the standard deviation of the objective values at the vertices of the simplex  is below <code>ϵ</code>. Default: <code>1e-2</code>.</li><li><code>λ::Float64</code> – multiplicative modification factor in (0, 1) for <code>θ_high_init</code> and <code>θ_low_init</code>, which is repeatedly applied in case the objective value is infinity until a feasible region is find. Default: <code>0.5</code>.</li><li><code>θ_high_init::Float64</code> – Initial guess for <code>θ_high</code>. Default: <code>3.0</code>.</li><li><code>θ_low_init::Float64</code> – Initial guess for <code>θ_low</code>. Default: <code>1e-8</code>.</li><li><code>iter_max::Int64</code> – maximum iteration number. Default: <code>100</code>.</li></ul><p><strong>Notes</strong></p><ul><li>The Nelder-Mead Simplex method maintains a 1D simplex (i.e. a line segment that consists of 2 points, <code>θ_high</code> and <code>θ_low</code>) to search for the optimal risk-sensitivity parameter <code>θ</code>. <code>θ_high</code> and <code>θ_low</code> refer to the verteces of the simplex with the highest and the lowest objective values, respectively.</li><li>The initial guesses <code>θ_high_init</code> and <code>θ_low_init</code>, which may be modified during optimization, are stored internally in the solver and carried over to the next call to <code>solve!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StanfordMSL/RATiLQR.jl/blob/fc0322cd48fced3bb920a9e90598528765ac73f8/src/nelder_mead_bilevel_optimization.jl#L11-L73">source</a></section></article><h2 id="PETS-Solver"><a class="docs-heading-anchor" href="#PETS-Solver">PETS Solver</a><a id="PETS-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#PETS-Solver" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RATiLQR.CrossEntropyDirectOptimizationSolver" href="#RATiLQR.CrossEntropyDirectOptimizationSolver"><code>RATiLQR.CrossEntropyDirectOptimizationSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CrossEntropyDirectOptimizationSolver(μ_init_array::Vector{Vector{Float64}},
Σ_init_array::Vector{Matrix{Float64}}; kwargs...)</code></pre><p>PETS Solver initialized with <code>μ_init_array = [μ_0,...,μ_{N-1}]</code> and <code>Σ_init_array = [Σ_0,...,Σ_{N-1}]</code>, where the initial control distribution at time <code>k</code> is a Gaussian distribution <code>Distributions.MvNormal(μ_k, Σ_k)</code>.</p><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>num_control_samples::Int64</code> – number of Monte Carlo samples for the control trajectory. Default: <code>10</code>.</li><li><code>num_trajectory_samples::Int64</code> – number of Monte Carlo samples for the state trajectory. Default: <code>10</code>.</li><li><code>num_elite::Int64</code> – number of elite samples. Default: <code>3</code>.</li><li><code>iter_max::Int64</code> – maximum iteration number. Default: <code>5</code>.</li><li><code>smoothing_factor::Float64</code> – smoothing factor in (0, 1), used to update the mean and the variance of the Cross Entropy distribution for the next iteration. If <code>smoothing_factor</code> is <code>0.0</code>, the updated distribution is independent of the previous iteration. If it is <code>1.0</code>, the updated distribution is the same as the previous iteration. Default. <code>0.1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StanfordMSL/RATiLQR.jl/blob/fc0322cd48fced3bb920a9e90598528765ac73f8/src/pets.jl#L14-L34">source</a></section></article><h2 id="The-solve!-Function"><a class="docs-heading-anchor" href="#The-solve!-Function">The <code>solve!</code> Function</a><a id="The-solve!-Function-1"></a><a class="docs-heading-anchor-permalink" href="#The-solve!-Function" title="Permalink"></a></h2><p>Once a problem is defined and a solver is instantiated, you can call <code>solve!</code> with appropriate arguments to perform optimization.</p><article class="docstring"><header><a class="docstring-binding" id="RATiLQR.solve!" href="#RATiLQR.solve!"><code>RATiLQR.solve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solve!(ileqg::ILEQGSolver, problem::FiniteHorizonRiskSensitiveOptimalControlProblem,
x_0::Vector{Float64}, u_array::Vector{Vector{Float64}}, θ::Float64, verbose=true)</code></pre><p>Given <code>problem</code>, and <code>ileqg</code> solver, solve iLQG (if <code>θ == 0</code>) or iLEQG (if <code>θ &gt; 0</code>) with current state <code>x_0</code> and nominal control schedule <code>u_array = [u_0, ..., u_{N-1}]</code>.</p><p><strong>Return Values (Ordered)</strong></p><ul><li><code>x_array::Vector{Vector{Float64}}</code> – nominal state trajectory <code>[x_0,...,x_N]</code>.</li><li><code>l_array::Vector{Vector{Float64}}</code> – nominal control schedule <code>[l_0,...,l_{N-1}]</code>.</li><li><code>L_array::Vector{Matrix{Float64}}</code> – feedback gain schedule <code>[L_0,...,L_{N-1}]</code>.</li><li><code>value::Float64</code> – optimal cost-to-go (i.e. value) found by the solver.</li><li><code>ϵ_history::Vector{Float64}</code> – history of line search step sizes used during the iLEQG iteration. Mainly for debugging purposes.</li></ul><p><strong>Notes</strong></p><ul><li>Returns a time-varying affine state-feedback policy <code>π_k</code> of the form <code>π_k(x) = L_k(x - x_k) + l_k</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StanfordMSL/RATiLQR.jl/blob/fc0322cd48fced3bb920a9e90598528765ac73f8/src/ileqg.jl#L578-L596">source</a></section><section><div><pre><code class="language-none">solve!(ce_solver::CrossEntropyBilevelOptimizationSolver,
problem::FiniteHorizonRiskSensitiveOptimalControlProblem,
x_0::Vector{Float64}, u_array::Vector{Vector{Float64}}, rng::AbstractRNG;
kl_bound::Float64, verbose=true, serial=false)</code></pre><p>Given <code>problem</code> and <code>ce_solver</code> (i.e. a RAT iLQR Solver), solve distributionally robust control with current state <code>x_0</code> and nominal control schedule <code>u_array = [u_0, ..., u_{N-1}]</code> under the KL divergence bound of <code>kl_bound</code> (&gt;= 0).</p><p><strong>Return Values (Ordered)</strong></p><ul><li><code>θ_opt::Float64</code> – optimal risk-sensitivity parameter.</li><li><code>x_array::Vector{Vector{Float64}}</code> – nominal state trajectory <code>[x_0,...,x_N]</code>.</li><li><code>l_array::Vector{Vector{Float64}}</code> – nominal control schedule <code>[l_0,...,l_{N-1}]</code>.</li><li><code>L_array::Vector{Matrix{Float64}}</code> – feedback gain schedule <code>[L_0,...,L_{N-1}]</code>.</li><li><code>value::Float64</code> – optimal cost-to-go (i.e. objective value) found by the solver.</li><li><code>θ_min::Float64</code> – minimum feasible risk-sensitivity parameter found.</li><li><code>θ_max::Float64</code> – maximum feasible risk-sensitivity parameter found.</li></ul><p><strong>Notes</strong></p><ul><li>Returns a time-varying affine state-feedback policy <code>π_k</code> of the form <code>π_k(x) = L_k(x - x_k) + l_k</code>.</li><li>If <code>kl_bound</code> is 0.0, the solver reduces to iLQG.</li><li>If <code>serial</code> is <code>true</code>, Monte Carlo sampling of the Cross Entropy method is serialized on a single process. If <code>false</code> it is distributed on all the available worker processes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StanfordMSL/RATiLQR.jl/blob/fc0322cd48fced3bb920a9e90598528765ac73f8/src/cross_entropy_bilevel_optimization.jl#L341-L366">source</a></section><section><div><pre><code class="language-none">solve!(nm_solver::NelderMeadBilevelOptimizationSolver,
problem::FiniteHorizonRiskSensitiveOptimalControlProblem, x_0::Vector{Float64},
u_array::Vector{Vector{Float64}}; kl_bound::Float64, verbose=true)</code></pre><p>Given <code>problem</code> and <code>nm_solver</code> (i.e. a RAT iLQR++ Solver), solve distributionally robust control with current state <code>x_0</code> and nominal control schedule <code>u_array = [u_0, ..., u_{N-1}]</code> under the KL divergence bound of <code>kl_bound</code> (&gt;= 0).</p><p><strong>Return Values (Ordered)</strong></p><ul><li><code>θ_opt::Float64</code> – optimal risk-sensitivity parameter.</li><li><code>x_array::Vector{Vector{Float64}}</code> – nominal state trajectory <code>[x_0,...,x_N]</code>.</li><li><code>l_array::Vector{Vector{Float64}}</code> – nominal control schedule <code>[l_0,...,l_{N-1}]</code>.</li><li><code>L_array::Vector{Matrix{Float64}}</code> – feedback gain schedule <code>[L_0,...,L_{N-1}]</code>.</li><li><code>value::Float64</code> – optimal cost-to-go (i.e. objective value) found by the solver.</li></ul><p><strong>Notes</strong></p><ul><li>Returns a time-varying affine state-feedback policy <code>π_k</code> of the form <code>π_k(x) = L_k(x - x_k) + l_k</code>.</li><li>If <code>kl_bound</code> is 0.0, the solver reduces to iLQG.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StanfordMSL/RATiLQR.jl/blob/fc0322cd48fced3bb920a9e90598528765ac73f8/src/nelder_mead_bilevel_optimization.jl#L258-L278">source</a></section><section><div><pre><code class="language-none">solve!(direct_solver::CrossEntropyDirectOptimizationSolver,
problem::FiniteHorizonGenerativeOptimalControlProblem, x_0::Vector{Float64},
rng::AbstractRNG; use_true_model=false, verbose=true, serial=true)</code></pre><p>Given <code>problem</code> and <code>direct_solver</code> (i.e. a PETS Solver), solve stochastic optimal control with current state <code>x_0</code>.</p><p><strong>Return Values (Ordered)</strong></p><ul><li><code>μ_array::Vector{Vector{Float64}}</code> – array of means <code>[μ_0,...,μ_{N-1}]</code> for the final Cross Entropy distribution for the control schedule.</li><li><code>Σ_array::Vector{Matrix{Float64}}</code> – array of covariance matrices <code>[Σ_0,...,Σ_{N-1}]</code> for the final Cross Entropy distribution for the control schedule.</li></ul><p><strong>Notes</strong></p><ul><li>Returns an open-loop control policy.</li><li>If <code>use_true_model</code> is <code>true</code>, the solver uses the true stochastic dynamics model defined in <code>problem.f_stochastic</code>.</li><li>If <code>serial</code> is <code>true</code>, Monte Carlo sampling of the Cross Entropy method is serialized on a single process. If <code>false</code> it is distributed on all the available worker processes. We recommend to leave this to <code>true</code> as distributed processing can be slower for this algorithm.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StanfordMSL/RATiLQR.jl/blob/fc0322cd48fced3bb920a9e90598528765ac73f8/src/pets.jl#L247-L269">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optimal-control/">« Optimal Control Problems</a><a class="docs-footer-nextpage" href="../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 7 January 2021 18:47">Thursday 7 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
